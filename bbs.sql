-- MySQL dump 10.13  Distrib 5.7.17, for Linux (x86_64)
--
-- Host: localhost    Database: bbs
-- ------------------------------------------------------
-- Server version	5.7.20-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `permission`
--

LOCK TABLES `permission` WRITE;
/*!40000 ALTER TABLE `permission` DISABLE KEYS */;
INSERT INTO `permission` VALUES (1,0,'','','话题节点'),(2,1,'/topic/create','topic:add','创建话题'),(3,1,'/topic/edit/[0-9]+','topic:edit','编辑话题'),(4,1,'/topic/delete/[0-9]+','topic:delete','删除话题'),(5,0,'','','回复节点'),(6,5,'/reply/delete/[0-9]+','reply:delete','删除回复'),(7,5,'/reply/save','reply:save','创建回复'),(8,5,'/reply/up','reply:up','点赞回复'),(12,0,'','','权限节点'),(13,12,'/user/list','user:list','用户列表'),(14,12,'/user/edit/[0-9]+','user:edit','角色配置'),(15,12,'/user/delete/[0-9]+','user:delete','用户删除'),(16,12,'/role/list','role:list','角色列表'),(17,12,'/role/add','role:add','添加角色'),(18,12,'/role/delete/[0-9]+','role:delete','删除角色'),(20,12,'/role/edit/[0-9]+','role:edit','编辑角色'),(21,12,'/permission/list','permission:list','权限列表'),(22,12,'/permission/add','permission:add','添加权限'),(23,12,'/permission/edit/[0-9]+','permission:edit','编辑权限'),(24,12,'/permission/delete/[0-9]+','permission:delete','删除权限');
/*!40000 ALTER TABLE `permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `reply`
--

LOCK TABLES `reply` WRITE;
/*!40000 ALTER TABLE `reply` DISABLE KEYS */;
INSERT INTO `reply` VALUES (1,1,'可以',1,0,'2016-08-27 09:22:52');
/*!40000 ALTER TABLE `reply` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `reply_up_log`
--

LOCK TABLES `reply_up_log` WRITE;
/*!40000 ALTER TABLE `reply_up_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `reply_up_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `role`
--

LOCK TABLES `role` WRITE;
/*!40000 ALTER TABLE `role` DISABLE KEYS */;
INSERT INTO `role` VALUES (5,'普通用户'),(4,'版主'),(3,'超级管理员');
/*!40000 ALTER TABLE `role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `role_permissions`
--

LOCK TABLES `role_permissions` WRITE;
/*!40000 ALTER TABLE `role_permissions` DISABLE KEYS */;
INSERT INTO `role_permissions` VALUES (64,3,2),(65,3,3),(66,3,4),(67,3,6),(68,3,7),(69,3,8),(70,3,13),(71,3,14),(72,3,15),(73,3,16),(74,3,17),(75,3,18),(76,3,20),(77,3,21),(78,3,22),(79,3,23),(80,3,24),(81,5,2),(82,5,7),(83,5,8),(84,4,2),(85,4,3),(86,4,4),(87,4,6);
/*!40000 ALTER TABLE `role_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `section`
--

LOCK TABLES `section` WRITE;
/*!40000 ALTER TABLE `section` DISABLE KEYS */;
INSERT INTO `section` VALUES (1,'分享'),(3,'博客'),(9,'外包'),(4,'招聘'),(8,'数据库'),(6,'新闻'),(5,'框架'),(10,'比赛'),(7,'语言'),(2,'问答');
/*!40000 ALTER TABLE `section` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `tmp_topic_factor`
--

LOCK TABLES `tmp_topic_factor` WRITE;
/*!40000 ALTER TABLE `tmp_topic_factor` DISABLE KEYS */;
/*!40000 ALTER TABLE `tmp_topic_factor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `tmp_user_factor`
--

LOCK TABLES `tmp_user_factor` WRITE;
/*!40000 ALTER TABLE `tmp_user_factor` DISABLE KEYS */;
/*!40000 ALTER TABLE `tmp_user_factor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `topic`
--

LOCK TABLES `topic` WRITE;
/*!40000 ALTER TABLE `topic` DISABLE KEYS */;
INSERT INTO `topic` VALUES (5,'你好鼓励师','感谢安老师又为我们写了一本好书《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》','2017-08-26 09:22:42',1,3,10,0,0,0,'2017-08-26 09:22:42'),(6,' 基于Linux平台，棋牌游戏服务器的架设','项目描述：\r\n棋牌游戏是现成的，同时支持PC，安卓和Ios三个平台，架设所用服务器由本人提供\r\n\r\n1，需求\r\n\r\n完成本棋牌游戏服务器的架设，并录制架设视屏，架设视屏内容必须完整清晰。（服务器配置，架设环境要求，架设过程中所使用到的工具等等）\r\n\r\n\r\n\r\n2，验收标准\r\n\r\n服务器架设完，游戏必须能够正常登录操作\r\n\r\n提交本棋牌游戏完整的服务器架设视频验收（本人会根据视频重新架设一次，确保视频内容和本次架设结果一致）\r\n\r\n确保在规定时间内完成此项任务（具体时间详谈）\r\n\r\n\r\n\r\n3，对接包方非硬性要求\r\n\r\n有棋牌游戏架设经验的请注明，本人会择情优先考虑。\r\n\r\n注：此次架设只是测试性架设，后期还会对本棋牌游戏进行二次开发，开发内容主要涉及UI，同时具备这两项技能的接包方可以注明，本人也会择情考虑。','2018-02-28 19:28:13',4,9,1,0,0,NULL,'2018-02-28 19:28:13'),(7,'外贸购物商城网站开发','项目描述：\r\n基本需求：\r\n\r\n\r\n\r\n一、技术要求\r\n\r\n\r\n\r\n使用PHP开发，使用ThinkPHP框架开发，提供源代码，代码可读性高\r\n\r\n\r\n\r\n二、前端\r\n\r\n\r\n\r\n最好有现成的外贸网站案例、功能差不多可考虑直接购买案例，或模仿https://www.tomtop.com/\r\n\r\n\r\n\r\n三、后台\r\n\r\n\r\n\r\n1、数据纵横\r\n\r\n\r\n\r\n要求后台可以统计网站的访客来源，浏览量，访客数，支付订单数，支付金额，支付买家数，流量下单转化率；\r\n\r\n\r\n\r\n同时可以统计每个产品的浏览量，访客数，支付订单数，支付金额，支付买家数，流量下单转化率。\r\n\r\n\r\n\r\n2、产品管理\r\n\r\n\r\n\r\n上传，上架，下架，删除，编辑等\r\n\r\n\r\n\r\n3、订单管理\r\n\r\n\r\n\r\n订单状态：待支付，待发货，风控中，已发货；\r\n\r\n\r\n\r\n可以导出订单，在代发货订单中填写订单号后，可以把填写订单号的excel上传完成发货，同时邮件通知买家；\r\n\r\n\r\n\r\n4、客服信息管理\r\n\r\n\r\n\r\n查看全部、未回复、已回复、已读、未读信息\r\n\r\n\r\n\r\n发件人搜索、回复等\r\n\r\n\r\n\r\n5、会员管理\r\n\r\n\r\n\r\n可以导出会员信息、会员可以在会员中心查看购买信息，购买记录，已经发货单号；\r\n\r\n\r\n\r\n6、后台用户管理\r\n\r\n\r\n\r\n角色管理、管理员\r\n\r\n\r\n\r\n\r\n\r\n开发周期：\r\n\r\n\r\n\r\n越快越好\r\n\r\n\r\n\r\n\r\n\r\n人员要求：\r\n\r\n\r\n\r\n有外贸商城网站开发案例优先\r\n\r\n\r\n\r\n请竞标后联系QQ','2018-02-28 20:14:38',4,9,1,0,0,NULL,'2018-02-28 20:14:38'),(8,'资源交流平台开发','项目描述：\r\n下载网站，主要包括会员，上传，支付，下载，后台包括会员管理，资源审核处理，各类统计（下载统计，分成统计等），评论管理\r\n\r\n\r\n\r\n易于操作与搜索，各类资源通过分类和各种标识易于查找。主要是学科类的联结比较复杂一些，要通过各版本课文目录，省市，知识点等联结资源。\r\n\r\n\r\n\r\n新系统要导入旧系统中会员和资源等数据，并且通过优化利于搜索引擎过渡到新系统。\r\n\r\n旧系统是mssql数据库，新系统使用语言不限，数据库不限，但要支持内容全文搜索。\r\n\r\n界面没特别设计的要求。\r\n\r\n参考网站 zxxk.com http://www.jinchutou.com/\r\n\r\n具体再交流，要有类似产品优先。\r\n\r\nbyboy8于2017-11-01 15:15:25补充了项目描述：\r\n希望能提交一些案例，项目说明上未竞的部分，请加QQ681906交流，寻诚意并长期合作者，如果能有志同道合的朋友就更佳了。','2018-02-28 20:23:53',4,9,2,0,0,NULL,'2018-02-28 20:23:53'),(9,'《阿里巴巴Android开发手册》正式发布，献给移动开发者的新年礼物','阿里Android开发经验结晶\r\n\r\n2017年天猫双11，成交额再创新高达到1682亿元，其中无线交易额占比90%；2017年12月，钉钉在诞生1075天后，注册用户突破1亿；而在同期，闲鱼用户也突破了2亿……面对如此大的用户量和流量，这些App依然可以做到“丝般顺滑”。 \r\n在这背后，是阿里巴巴移动开发团队的不断探索和优化，久而久之，这些经验汇总成了一套完善的开发规范，指导工程师开发出体验好、性能优、稳定性佳、安全性高的App。\r\n\r\n该开发规范在阿里内部经过了不断完善，现在整理成册，并向业界Android开发者开放，希望能够帮助企业和开发者少走弯路，提升Android开发的质量和效率。\r\n\r\n规范内容概览\r\n\r\n本手册以开发者为中心视角分为Java语言规范（遵循《阿里巴巴Java开发手册》），Android资源文件命名与使用，Android基本组件，UI与布局，进程、线程与消息通信，文件与数据库，Bitmap、Drawable与动画，安全以及其他等九大部分。\r\n\r\n手册免费下载：http://click.aliyun.com/m/42914/\r\n\r\n认证考试：http://click.aliyun.com/m/42915/','2018-03-01 09:14:42',5,6,4,0,0,NULL,'2018-03-01 09:14:42'),(10,'分享一个在线MarkDown编辑器','\n## MaHua是什么?\n一个在线编辑markdown文档的编辑器\n\n向Mac下优秀的markdown编辑器mou致敬\n\n## MaHua有哪些功能？\n\n* 方便的`导入导出`功能\n    *  直接把一个markdown的文本文件拖放到当前这个页面就可以了\n    *  导出为一个html格式的文件，样式一点也不会丢失\n* 编辑和预览`同步滚动`，所见即所得（右上角设置）\n* `VIM快捷键`支持，方便vim党们快速的操作 （右上角设置）\n* 强大的`自定义CSS`功能，方便定制自己的展示\n* 有数量也有质量的`主题`,编辑器和预览区域\n* 完美兼容`Github`的markdown语法\n* 预览区域`代码高亮`\n* 所有选项自动记忆\n\n## 有问题反馈\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\n\n* 邮件(dev.hubo#gmail.com, 把#换成@)\n* QQ: 287759234\n* weibo: [@草依山](http://weibo.com/ihubo)\n* twitter: [@ihubo](http://twitter.com/ihubo)\n\n## 捐助开发者\n在兴趣的驱动下,写一个`免费`的东西，有欣喜，也还有汗水，希望你喜欢我的作品，同时也能支持一下。\n当然，有钱捧个钱场（右上角的爱心标志，支持支付宝和PayPal捐助），没钱捧个人场，谢谢各位。\n\n## 感激\n感谢以下的项目,排名不分先后\n\n* [mou](http://mouapp.com/) \n* [ace](http://ace.ajax.org/)\n* [jquery](http://jquery.com)\n\n## 关于作者\n\n```javascript\n  var ihubo = {\n    nickName  : \"草依山\",\n    site : \"http://jser.me\"\n  }\n```','2018-03-01 09:29:13',6,1,5,0,0,NULL,'2018-03-01 09:29:13'),(11,'招聘：小程序开发（前端开发、​Java后台开发）','公司：潭州教育\r\n介绍：潭州教育于2007年成立，拥有3000余人师资团队，是国内一家的在线教育集团公司。潭州教育科技集团总部座落于星城长沙，2015年9月潭州教育正式入驻于芯城科技园，目前拥有两栋办公大楼近4万平米办公面积。\r\n\r\n前端开发（长沙）\r\n岗位职责：\r\n\r\n1、负责公司小程序相关的Javascript开发、维护；\r\n2、负责持续优化小程序的用户体验和可用性；\r\n3、负责Javascript程序模块的开发，通用类库和框架的编写；\r\n4、负责制定产品前端代码的规范，最大限度地实现代码的可重用性。\r\n\r\n任职要求：\r\n\r\n1、3年以上前端开发经验，熟练使用主流的MVVM框架中的任何一种，如：ReactJS、vue、js、AngularJs；\r\n2、熟练掌握javascript面向对象编程方法；\r\n3、对css/JavaScript性能优化、解决多浏览器兼容性问题有一定的经验；\r\n4、有ES6/7实践经验优先考虑；\r\n5、自学能力好，对技术充满热情；\r\n6、富有责任心，善于沟通、乐于分享、工作认真负责高效；\r\n7、有较强的沟通能力和团队合作精神；\r\n','2018-03-01 09:59:20',1,4,1,0,0,NULL,'2018-03-01 09:59:20'),(12,'JVM 堆内存设置原理','堆内存设置\r\n\r\n原理\r\n\r\nJVM堆内存分为2块：Permanent Space 和 Heap Space。\r\nPermanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。\r\nHeap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。\r\n年轻代\r\n\r\n所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。\r\n\r\n大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。\r\n\r\n2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。\r\n\r\n针对年轻代的垃圾回收即 Young GC。\r\n\r\n年老代\r\n\r\n在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\r\n\r\n针对年老代的垃圾回收即 Full GC。\r\n\r\n持久代\r\n\r\n用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。\r\n\r\n\r\n\r\n所以，当一组对象生成时，内存申请过程如下：\r\n\r\nJVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。\r\n当Eden区空间足够时，内存申请结束。否则执行下一步。\r\nJVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。\r\nSurvivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。\r\n当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。\r\nFull GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。\r\nOOM（“Out of Memory”）异常一般主要有如下2种原因：\r\n\r\n1. 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace\r\n这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。\r\n例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。\r\n\r\n2. 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace\r\n通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。\r\n参数说明\r\n\r\n-Xmx3550m：设置JVM最大堆内存为3550M。\r\n-Xms3550m：设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。\r\n-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会在很大程度上降低系统的性能。\r\n-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。\r\n-XX:NewSize=1024m：设置年轻代初始值为1024M。\r\n-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。\r\n-XX:PermSize=256m：设置持久代初始值为256M。\r\n-XX:MaxPermSize=256m：设置持久代最大值为256M。\r\n-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。\r\n-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。\r\n-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。\r\n疑问解答\r\n\r\n-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？\r\n如下：\r\n高优先级：-XX:NewSize/-XX:MaxNewSize \r\n中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） \r\n低优先级：-XX:NewRatio \r\n推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。\r\n-Xmn参数是在JDK 1.4 开始支持。\r\n\r\n垃圾回收器选择\r\n\r\nJVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。\r\n\r\n默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。\r\n\r\n串行收集器\r\n\r\n-XX:+UseSerialGC：设置串行收集器。\r\n并行收集器（吞吐量优先）\r\n\r\n-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。\r\n-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。\r\n-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。\r\n-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。\r\n-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。\r\n并发收集器（响应时间优先）\r\n\r\n-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。\r\n-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。\r\n-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。\r\n-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。\r\n-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。\r\n-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。\r\n其它垃圾回收参数\r\n\r\n-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。\r\n-XX:-DisableExplicitGC：不响应 System.gc() 代码。\r\n-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。\r\n-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。\r\n-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。\r\n辅助信息参数设置\r\n\r\n-XX:-CITime：打印消耗在JIT编译的时间。\r\n-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。\r\n-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。\r\n-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。\r\n-XX:OnError=\";\"：出现致命ERROR后运行自定义命令。\r\n-XX:OnOutOfMemoryError=\";\"：当首次遭遇内存溢出时执行自定义命令。\r\n-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。\r\n-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。\r\n-XX:-PrintCompilation：当一个方法被编译时打印相关信息。\r\n-XX:-PrintGC：每次GC时打印相关信息。\r\n-XX:-PrintGCDetails：每次GC时打印详细信息。\r\n-XX:-PrintGCTimeStamps：打印每次GC的时间戳。\r\n-XX:-TraceClassLoading：跟踪类的加载信息。\r\n-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。\r\n-XX:-TraceClassResolution：跟踪常量池。\r\n-XX:-TraceClassUnloading：跟踪类的卸载信息。\r\n关于参数名称等\r\n\r\n标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；例如：\r\n-client——设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。\r\n-server——设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。\r\n非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；\r\n非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；\r\n\r\nJVM服务参数调优实战\r\n\r\n大型网站服务器案例\r\n\r\n承受海量访问的动态Web应用\r\n\r\n服务器配置：8 CPU, 8G MEM, JDK 1.6.X\r\n\r\n参数方案：\r\n\r\n-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC\r\n\r\n调优说明：\r\n\r\n-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。\r\n-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。\r\n-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。\r\n-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。\r\n-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。\r\n-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。\r\n-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。\r\n内部集成构建服务器案例\r\n\r\n高性能数据处理的工具应用\r\n服务器配置：1 CPU, 4G MEM, JDK 1.6.X\r\n\r\n参数方案：\r\n\r\n-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m\r\n\r\n调优说明：\r\n\r\n-XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。\r\n-Xmn320m 遵循年轻代大小为整个堆的3/8原则。\r\n-Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。\r\n在64位服务器上运行应用程序，构建执行时，用 jmap -heap 11540 命令观察JVM堆内存状况如下：\r\n\r\nAttaching to process ID 11540, please wait...\r\nDebugger attached successfully.\r\nServer compiler detected.\r\nJVM version is 20.12-b01\r\n\r\n\r\nusing thread-local object allocation.\r\nParallel GC with 4 thread(s)\r\n\r\n\r\nHeap Configuration:\r\n   MinHeapFreeRatio = 40\r\n   MaxHeapFreeRatio = 70\r\n   MaxHeapSize      = 1073741824 (1024.0MB)\r\n   NewSize          = 335544320 (320.0MB)\r\n   MaxNewSize       = 335544320 (320.0MB)\r\n   OldSize          = 5439488 (5.1875MB)\r\n   NewRatio         = 2\r\n   SurvivorRatio    = 8\r\n   PermSize         = 205520896 (196.0MB)\r\n   MaxPermSize      = 205520896 (196.0MB)\r\n\r\n\r\nHeap Usage:\r\nPS Young Generation\r\nEden Space:\r\n   capacity = 255852544 (244.0MB)\r\n   used     = 101395504 (96.69828796386719MB)\r\n   free     = 154457040 (147.3017120361328MB)\r\n   39.63044588683081% used\r\nFrom Space:\r\n   capacity = 34144256 (32.5625MB)\r\n   used     = 33993968 (32.41917419433594MB)\r\n   free     = 150288 (0.1433258056640625MB)\r\n   99.55984397492803% used\r\nTo Space:\r\n   capacity = 39845888 (38.0MB)\r\n   used     = 0 (0.0MB)\r\n   free     = 39845888 (38.0MB)\r\n   0.0% used\r\nPS Old Generation\r\n   capacity = 469762048 (448.0MB)\r\n   used     = 44347696 (42.29325866699219MB)\r\n   free     = 425414352 (405.7067413330078MB)\r\n   9.440459523882184% used\r\nPS Perm Generation\r\n   capacity = 205520896 (196.0MB)\r\n   used     = 85169496 (81.22396087646484MB)\r\n   free     = 120351400 (114.77603912353516MB)\r\n   41.440796365543285% used\r\n\r\n结果是比较健康的。','2018-03-01 10:00:35',1,3,1,0,0,NULL,'2018-03-01 10:00:35'),(13,'Android解析WindowManagerService（三）Window的删除过程','前言\r\n\r\n在本系列文章中，我提到过：Window的操作分为两大部分，一部分是WindowManager处理部分，另一部分是WMS处理部分，Window的删除过程也不例外，本篇文章会介绍Window的删除过程，包括了两大处理部分的内容。\r\n\r\nWindow的删除过程\r\n\r\n和Android解析WindowManagerService（二）WMS的重要成员和Window的添加过程这篇文章中Window的创建和更新过程类似，要删除Window需要先调用WindowManagerImpl的removeView方法，removeView方法中又会调用WindowManagerGlobal的removeView方法，我们就从这里开始讲起。为了表述的更易于理解，本文将要删除的Window（View）简称为V。WindowManagerGlobal的removeView方法如下所示。\r\n\r\nframeworks/base/core/java/android/view/WindowManagerGlobal.java\r\n\r\npublic void removeView(View view, boolean immediate) {\r\n      if (view == null) {\r\n          throw new IllegalArgumentException(\"view must not be null\");\r\n      }\r\n      synchronized (mLock) {\r\n          int index = findViewLocked(view, true);//1\r\n          View curView = mRoots.get(index).getView();\r\n          removeViewLocked(index, immediate);//2\r\n          if (curView == view) {\r\n              return;\r\n          }\r\n          throw new IllegalStateException(\"Calling with view \" + view\r\n                  + \" but the ViewAncestor is attached to \" + curView);\r\n      }\r\n  }\r\n注释1处找到要V在View列表中的索引，在注释2处调用了removeViewLocked方法并将这个索引传进去，如下所示。\r\nframeworks/base/core/java/android/view/WindowManagerGlobal.java\r\n\r\nprivate void removeViewLocked(int index, boolean immediate) {\r\n       ViewRootImpl root = mRoots.get(index);//1\r\n       View view = root.getView();\r\n       if (view != null) {\r\n           InputMethodManager imm = InputMethodManager.getInstance();//2\r\n           if (imm != null) {\r\n               imm.windowDismissed(mViews.get(index).getWindowToken());//3\r\n           }\r\n       }\r\n       boolean deferred = root.die(immediate);//4\r\n       if (view != null) {\r\n           view.assignParent(null);\r\n           if (deferred) {\r\n               mDyingViews.add(view);\r\n           }\r\n       }\r\n   }\r\n注释1处根据传入的索引在ViewRootImpl列表中获得V的ViewRootImpl。注释2处得到InputMethodManager实例，如果InputMethodManager实例不为null则在注释3处调用InputMethodManager的windowDismissed方法来结束V的输入法相关的逻辑。注释4处调用ViewRootImpl 的die方法，如下所示。\r\n\r\nframeworks/base/core/java/android/view/ViewRootImpl.java\r\n\r\nboolean die(boolean immediate) {\r\n      //die方法需要立即执行并且此时ViewRootImpl不在执行performTraversals方法\r\n      if (immediate && !mIsInTraversal) {//1\r\n          doDie();//2\r\n          return false;\r\n      }\r\n      if (!mIsDrawing) {\r\n          destroyHardwareRenderer();\r\n      } else {\r\n          Log.e(mTag, \"Attempting to destroy the window while drawing!\\n\" +\r\n                  \"  window=\" + this + \", title=\" + mWindowAttributes.getTitle());\r\n      }\r\n      mHandler.sendEmptyMessage(MSG_DIE);\r\n      return true;\r\n  }\r\n注释1处如果immediate为ture（需要立即执行），并且mIsInTraversal值为false则执行注释2处的代码，mIsInTraversal在执行ViewRootImpl的performTraversals方法时会被设置为true，在performTraversals方法执行完时被设置为false，因此注释1处可以理解为die方法需要立即执行并且此时ViewRootImpl不在执行performTraversals方法。注释2处的doDie方法如下所示。\r\nframeworks/base/core/java/android/view/ViewRootImpl.java\r\n\r\nvoid doDie() {\r\n    //检查执行doDie方法的线程的正确性\r\n    checkThread();//1\r\n    if (LOCAL_LOGV) Log.v(mTag, \"DIE in \" + this + \" of \" + mSurface);\r\n    synchronized (this) {\r\n        if (mRemoved) {//2\r\n            return;\r\n        }\r\n        mRemoved = true;//3\r\n        if (mAdded) {//4\r\n            dispatchDetachedFromWindow();//5\r\n        }\r\n        if (mAdded && !mFirst) {//6\r\n            destroyHardwareRenderer();\r\n            if (mView != null) {\r\n                int viewVisibility = mView.getVisibility();\r\n                boolean viewVisibilityChanged = mViewVisibility != viewVisibility;\r\n                if (mWindowAttributesChanged || viewVisibilityChanged) {\r\n                    try {\r\n                        if ((relayoutWindow(mWindowAttributes, viewVisibility, false)\r\n                                & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {\r\n                            mWindowSession.finishDrawing(mWindow);\r\n                        }\r\n                    } catch (RemoteException e) {\r\n                    }\r\n                }\r\n                mSurface.release();\r\n            }\r\n        }\r\n        mAdded = false;\r\n    }\r\n    WindowManagerGlobal.getInstance().doRemoveView(this);//7\r\n}\r\n注释1处用于检查执行doDie方法的线程的正确性，注释1的内部会判断执行doDie方法线程是否是创建V的原始线程，如果不是就会抛出异常，这是因为只有创建V的原始线程才能够操作V。注释2到注释3处的代码用于防止doDie方法被重复调用。注释4处V有子View就会调用dispatchDetachedFromWindow方法来销毁View。注释6处如果V有子View并且不是第一次被添加，就会执行后面的代码逻辑。注释7处的WindowManagerGlobal的doRemoveView方法，如下所示。\r\nframeworks/base/core/java/android/view/WindowManagerGlobal.java\r\n\r\nvoid doRemoveView(ViewRootImpl root) {\r\n      synchronized (mLock) {\r\n          final int index = mRoots.indexOf(root);//1\r\n          if (index >= 0) {\r\n              mRoots.remove(index);\r\n              mParams.remove(index);\r\n              final View view = mViews.remove(index);\r\n              mDyingViews.remove(view);\r\n          }\r\n      }\r\n      if (ThreadedRenderer.sTrimForeground && ThreadedRenderer.isAvailable()) {\r\n          doTrimForeground();\r\n      }\r\n  }\r\nWindowManagerGlobal中维护了和 Window操作相关的三个列表，doRemoveView方法会从这三个列表中清除V对应的元素。注释1处找到V对应的ViewRootImpl在ViewRootImpl列表中的索引，接着根据这个索引从ViewRootImpl列表、布局参数列表和View列表中删除与V对应的元素。\r\n我们接着回到ViewRootImpl的doDie方法，查看注释5处的dispatchDetachedFromWindow方法里做了什么：\r\nframeworks/base/core/java/android/view/ViewRootImpl.java\r\n\r\nvoid dispatchDetachedFromWindow() {\r\n    ...\r\n      try {\r\n          mWindowSession.remove(mWindow);\r\n      } catch (RemoteException e) {\r\n      }\r\n      ...\r\n  }\r\ndispatchDetachedFromWindow方法中主要调用了IWindowSession的remove方法，IWindowSession在Server端的实现为Session，Session的remove方法如下所示。\r\nframeworks/base/services/core/java/com/android/server/wm/Session.java\r\n\r\npublic void remove(IWindow window) {\r\n     mService.removeWindow(this, window);\r\n }\r\n接着查看WMS的removeWindow方法：\r\nframeworks/base/services/core/java/com/android/server/wm/WindowManagerService .java\r\n\r\nvoid removeWindow(Session session, IWindow client) {\r\n     synchronized(mWindowMap) {\r\n         WindowState win = windowForClientLocked(session, client, false);//1\r\n         if (win == null) {\r\n             return;\r\n         }\r\n         win.removeIfPossible();//2\r\n     }\r\n }\r\n注释1处用于获取Window对应的WindowState，WindowState用于保存窗口的信息，在WMS中它用来描述一个窗口。接着在注释2处调用WindowState的removeIfPossible方法，如下所示。\r\nframeworks/base/services/core/java/com/android/server/wm/WindowState.java\r\n\r\nOverride\r\nvoid removeIfPossible() {\r\n    super.removeIfPossible();\r\n    removeIfPossible(false /*keepVisibleDeadWindow*/);\r\n}\r\n又会调用removeIfPossible方法，如下所示。\r\nframeworks/base/services/core/java/com/android/server/wm/WindowState.java\r\n\r\nprivate void removeIfPossible(boolean keepVisibleDeadWindow) {\r\n        ...条件判断过滤，满足其中一个条件就会return，推迟删除操作\r\n	removeImmediately();//1\r\n	if (wasVisible && mService.updateOrientationFromAppTokensLocked(false, displayId)) {\r\n		mService.mH.obtainMessage(SEND_NEW_CONFIGURATION, displayId).sendToTarget();\r\n	}\r\n	mService.updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/);\r\n	Binder.restoreCallingIdentity(origId);\r\n}\r\nremoveIfPossible方法和它的名字一样，并不是直接执行删除操作，而是进行多个条件判断过滤，满足其中一个条件就会return，推迟删除操作。比如这时V正在运行一个动画，这时就得推迟删除操作，直到动画完成。通过这些条件判断过滤就会执行注释1处的removeImmediately方法：\r\nframeworks/base/services/core/java/com/android/server/wm/WindowState.java\r\n\r\n@Override\r\nvoid removeImmediately() {\r\n    super.removeImmediately();\r\n    if (mRemoved) {//1\r\n        if (DEBUG_ADD_REMOVE) Slog.v(TAG_WM,\r\n                \"WS.removeImmediately: \" + this + \" Already removed...\");\r\n        return;\r\n    }\r\n    mRemoved = true;//2\r\n    ...\r\n    mPolicy.removeWindowLw(this);//3\r\n    disposeInputChannel();\r\n    mWinAnimator.destroyDeferredSurfaceLocked();\r\n    mWinAnimator.destroySurfaceLocked();\r\n    mSession.windowRemovedLocked();//4\r\n    try {\r\n        mClient.asBinder().unlinkToDeath(mDeathRecipient, 0);\r\n    } catch (RuntimeException e) {          \r\n    }\r\n    mService.postWindowRemoveCleanupLocked(this);//5\r\n}\r\nremoveImmediately方法如同它的名字一样，用于立即进行删除操作。注释1处的mRemoved为true意味着正在执行删除Window操作，注释1到注释2处之间的代码用于防止重复删除操作。注释3处如果当前要删除的Window是StatusBar或者NavigationBar就会将这个Window从对应的控制器中删除。注释4处会将V对应的Session从WMS的ArraySet<Session> mSessions中删除并清除Session对应的SurfaceSession资源（SurfaceSession是SurfaceFlinger的一个连接，通过这个连接可以创建1个或者多个Surface并渲染到屏幕上 ）。注释5处调用了WMS的postWindowRemoveCleanupLocked方法用于对V进行一些集中的清理工作，这里就不在继续深挖下去，有兴趣的同学可以自行查看源码。\r\n\r\nWindow的删除过程就讲到这里，虽然删除的操作逻辑比较复杂，但是可以简单的总结为以下4点：\r\n\r\n检查删除线程的正确性，如果不正确就抛出异常。\r\n从ViewRootImpl列表、布局参数列表和View列表中删除与V对应的元素。\r\n判断是否可以直接执行删除操作，如果不能就推迟删除操作。\r\n执行删除操作，清理和释放与V相关的一切资源。','2018-03-01 10:06:20',1,3,1,0,0,NULL,'2018-03-01 10:06:20'),(14,'AI研究公司面试准备指南','年已过尽，春招和实习已经在路上。相信大家对于去年秋招岗位的薪资多少有些了解，比较热门的一些岗位大多与人工智能相关，一些公司也开出了相当可观的薪资来抢人，这也表明了市场看好人工智能未来的发展。\r\n\r\n本篇内容主要是汇集了一些如何应付面试所需要的一些资源，有些内容不是很全面，读者有合适的素材也可以在下面留言补充。\r\n\r\n根据我的研究，网络上的资源可以分为四个主要的类别来研究：\r\n\r\n1.统计与概率\r\n\r\n2.其它相关的数学\r\n\r\n3.编程\r\n\r\n基础问答题的相关概念\r\n\r\n面试编程实践\r\n\r\n4.机器学习\r\n\r\n我知道人工智能一直以来是一个热门的话题，而且数据科学的进展很快，因此所找的链接主要是最近两年的材料（主要是在Reddit及其它论坛上找的相关材料）。\r\n\r\n速成课程材料（Reddit）\r\nOpenAi的建议（Reddit）\r\nGoogle Brain的建议（Reddit）\r\nDeepMind的建议（Reddit）\r\nDeepMind的其它博客\r\n在上面的帖子中没有找到大量有用的资料，并且发现阅读博客是构建整体战略的好方法。\r\n\r\n博客文章：\r\n\r\n转行：从事数据科学工作\r\n面试时我搞砸了\r\n数据科学面试\r\n如何准备机器学习面试\r\n数据科学面试答案 \r\n如何检索数据科学面试：统计学\r\n共同概率分布：数据科学家的小抄\r\n这样的帖子推荐的教材和Coursera课程有许多，我觉得以下教材和课程对于初学者是有用的，有时间的读者可以学习下。\r\n\r\n教材和课程：\r\n\r\nAndrew Ng的机器学习课程（Coursera）\r\nJohn Hopkins的生物统计学训练营（Coursera）\r\nRoss的概率论基础教程·第八版（PDF教材）\r\nCasella & Berger的统计推断·第二版（PDF教材）\r\n很多人喜欢“小抄”，我认为小抄是一个很好的助手，但过于密集的信息也可以作为主要材料使用，在这称之为“参考资料”。\r\n\r\n参考资料：\r\n\r\n概率分布概述（博客文章）\r\n数据科学（Python）：Keras & Numpy\r\n机器学习算法流程图/小抄\r\n如果你离面试还有一周的时间，我认为问题表可以作为最终的学习材料，如果问题表有配套的答案的话是最好的。问题表指导所要学习的内容以及掌握程度，否则网络上存在的资源实在是太多，无法抓住主要的内容学习。本文所找的内容也不是很全面，如果读者知道一些有用的素材，请在底下留言，我会将它们添加到列表之中。\r\n\r\n问题表：\r\n\r\n通用的：\r\n\r\nmockinterview.io越来越多的问题\r\n105道数据科学面试问题\r\n机器学习问题 \r\n21道数据科学面试问题及答案\r\n109道数据额科学面试问题\r\n概率：\r\n\r\n40道关于数据科学概率的问题和答案\r\n达特茅斯的概率论教材\r\n统计学：\r\n\r\n暂未有合适的材料\r\n数学：\r\n\r\n线性代数、集合论和代数、微积分、图论、组合学、命题与一阶逻辑：多项选择\r\n机器学习数学\r\n多元优化演算\r\n编程：\r\n\r\n破解编程面试：150个编程面试问题与解决方案（PDF教材）\r\n计算机科学多选题与答案\r\n更多计算机多选题与答案\r\n机器学习：\r\n\r\nAndrew Ng的Coursera课程中的测验与答案\r\n增强学习：\r\n\r\nSutton & Barto的增强学习导论（在线教材以及问题/解决方案）\r\n作者信息\r\n\r\nfive4three2，Reddit网站坛友\r\n\r\n个人主页：https://www.reddit.com/user/five4three2\r\n\r\n本文由北邮@爱可可-爱生活老师推荐，阿里云云栖社区组织翻译。\r\n\r\n文章原标题《Study Guides for Interview at AI Research Company》，作者：five4three2，译者：海棠，审阅：袁虎。','2018-03-01 10:07:39',1,4,1,0,0,NULL,'2018-03-01 10:07:39'),(15,'阿里巴巴测试环境稳定性提升实践','导读：测试环境是研发/测试同学最常用的功能，稳定性直接影响到研发效率，那如何提升测试环境的稳定性？阿里巴巴应用与基础运维平台高级开发工程师张劲，通过阿里内部实践，总结了一套测试环境稳定性提升方法，供大家参考。\r\n\r\n痛点\r\n\r\n每一次容器申请失败直接造成研发测试停滞， 同时带来答疑及问题排查(程序猿最怕的就是在代码写得正嗨的时候被人给打断，所以一般我都带耳机)，涉及到测试链路上各个系统。随着集团pouch化的全面推进，半年来测试环境日容器申请量暴增10倍以上，低成功率导致研发低效的问题越来越凸显，每天累计造成集团上百小时的研发测试停滞，损失不可接受，也渐渐成为了pouch化推进过程中的一个阻力。\r\n\r\n因此， 测试环境稳定性亟待大幅提升。\r\n\r\n如何提升，经过答疑汇总和错误分析，主要集中在两个方面：\r\n\r\n已成功申请的资源不可用\r\n测试环境宿主机较差(过保机器)，且虚拟比高，容易发生故障。\r\n宿主机故障时，其上的容器不会被自动迁移，很可能导致再次部署重启时失败。\r\n调度系统巡检会将故障宿主机置为不可调度，由于其上仍有容器，不能下线修复后重用， 造成机器资源越来越少。\r\n新申请资源时成功率低\r\n测试环境机器被分为优先级不同的资源池，资源池间机器资源不共享。\r\n测试环境机器的容量/余量不透明，没有告警，造成因资源不足的调度失败。\r\n因为测试环境与线上环境有很大不同，资源调度系统之前没有针对测试场景优化， 成功率不高。\r\n\r\n目标\r\n\r\n容器申请成功率：99.9%\r\n指标数据\r\n\r\n从一开始我们就觉的数据非常重要，没有相关的稳定性数据，那我们就无的放矢，根据数据我们就能找到需要优化的点以及持续优化的动力。所以项目开始阶段就做了挺长时间的数据收集工作。\r\n\r\n测试环境链路数据收集：从上至下包括Normandy(基础应用运维平台)，黄蜂(资源申请平台)，Zeus(二层调度)，Sigma(集团资源调度系统)；其中我们最关心的就是最终容器交付的成功率，以及失败case。失败case可以帮助我们分析整个系统中到底哪些地方存在问题，成功率趋势则帮助我们检验新的修复优化是否真的有效且稳定，也是最终成果的衡量指标。、\r\n测试环境链路稳定性数据展示平台：其实上下游的每个系统都有自己的数据，但是没有整合，有的用阿里表哥，有的是发邮件，有的则没有展示出来，所以做这样一个小东西的目的就是将上下游系统的数据统一整合在一个页面上，更便于查看分析问题。\r\n每日/周/月错误分析：收集每天的错误数量及样例，便于分析问题。\r\n\r\n已申请容器不可用\r\n\r\n容器自动置换\r\n\r\n容器自动置换是为了解决已申请的容器不可用问题，简单来说就是在另一台好的宿主机上扩一个新容器，然后将原来在故障宿主机上的旧容器下线。\r\n\r\n整个流程如下：Sigma(资源调度系统)自动巡检出故障宿主机(比如磁盘满/硬件故障等)，通知Atom(故障机替换)置换该故障宿主机上容器，Atom向Normandy(基础应用运维平台)发起机器置换流程。\r\n\r\n通过自动置换将故障机腾空，然后下线修复。\r\n\r\n新申请容器失败\r\n\r\n合理化资源池分配\r\n\r\n屏蔽底层系统失败\r\n\r\n因为测试环境与线上环境差异很大，一般测试环境使用的机器都是线上淘汰机，同时为了节省预算，每台宿主机的虚拟比都很高，导致在创建和使用容器时都特别容易失败，所以有必要做一个容器buffer池屏蔽掉底层失败对用户的影响。\r\n\r\nbuffer池的整个逻辑非常简单清晰：在测试环境容器生产链路靠近用户的一端嵌入buffer池，预生产一批容器，在用户需要的时候分配给他。即使申请buffer容器失败，依然可以按原生产链路继续生产容器。每次从buffer池申请一个容器后，buffer池会自动异步补充一个相同规格的容器进来，以维持buffer池的容量。\r\n\r\n如何确定buffer哪些规格的容器及池子的容量是另一个关键点：需要统计每种规格-镜像-资源池的历史申请量，按比例分配每种buffer的容量。同时为了保证即使在底层系统中断服务时，整个系统依然对用户可用，还需要确定高峰期的容器申请量，可允许中断时长以及测试环境机器资源， 用来确定整个buffer池子的容量。\r\n\r\n还需要考虑的一点是，用户也分为普通用户(研发测试人员)，系统用户(比如自动化测试系统等)，他们的优先级也不同，需要优先保证普通用户可用。\r\n\r\n同时为了最大程度的降低引入buffer池后可能对用户造成的影响，buffer池内加了许多动态开关，用于及时屏蔽某些功能。比如可针对具体应用设置是否需要修改容器主机名，此操作非常耗时，如果不改主机名，则平均不到1秒内会申请成功；如果某个应用不想使用buffer，也可立即屏蔽；如果buffer池本身出现问题，可以快速降级，在整个链路中去掉buffer功能。\r\n\r\n另外buffer池在交付buffer容器前会额外做一次检查，判断容器是否可用，避免容器交付后，因为容器不可用而导致的服务部署失败，用户使用不了等问题。buffer池内部也会定期清理脏容器(不可用, 数据不一致等)和补充新的buffer容器。','2018-03-01 10:09:17',1,3,1,0,0,NULL,'2018-03-01 10:09:17'),(16,'位运算的黑科技','最近在学NodeJs，然后练手做项目的时候想用下位运算，需求是除2舍小数位，于是想像Java一样，直接除2，发现并不行\r\n```\r\n    console.log(5/2);\r\n    sivan@sivan-All-Series:~/workspace/nodejs/interesting_book$ node h.js\r\n    2.5\r\n```\r\n想了下发现很正常，因为JavaScript是弱数据语言，全部的变量都可以用一个var来声明的，所以结果的表现是浮点型，确实很正常。\r\n于是换了一种方式，之间看Java的部分源码看到位运算的相关操作（后面会提），所以在这也试下位运算\r\n```\r\n    console.log(5/2>>1/2);\r\n    sivan@sivan-All-Series:~/workspace/nodejs/interesting_book$ node h.js\r\n    2\r\n```\r\n结果一试就不得了了，居然还真的试出来了\r\n而在js的运算符中，**算术运算符的优先级是大于移位运算符**的，也就是上面的代码可以换成这样\r\n```\r\n    console.log(2.5 >> 0.5);\r\n    sivan@sivan-All-Series:~/workspace/nodejs/interesting_book$ node h.js\r\n    2\r\n```\r\n而结果确实一样，觉得很黑科技，居然还能用浮点数做移位运算，右移0.5位？这么黑科技的，于是这个时候，去Java上尝试了一下\r\n![Java下的尝试](http://upload-images.jianshu.io/upload_images/5176645-8d3908d430ac5271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n这边就很正常啦，因为Java里面，整数之间进行运算，得到的数还是整数，也就是上面的图片实际上相当于(2 >> 0)\r\n于是测试下\r\n![换成浮点型](http://upload-images.jianshu.io/upload_images/5176645-51ea60e070fdf390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n![换成整型](http://upload-images.jianshu.io/upload_images/5176645-b7296b8ddb76a93d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n可见确实如同猜测一样\r\n于是，结合Java里出现的情况，对JS中的情况做了个猜测，**js在有算术运算和移位运算同时存在的情况下，会将算术运算的结果转成整型再运算**\r\n下面验证下猜测\r\n```\r\n    console.log(5/2>>1/2);\r\n    console.log(2.5 >> 0.5);\r\n    console.log(5/2 >> 0);\r\n    console.log(2 >> 1/2);\r\n    console.log(5.9/2 >> 0);\r\n    console.log(2 >> 0);\r\n```\r\n如无意外，这一批的log的结果，都会是2\r\n```\r\n    sivan@sivan-All-Series:~/workspace/nodejs/interesting_book$ node h.js\r\n    2\r\n    2\r\n    2\r\n    2  \r\n    2\r\n    2\r\n```\r\n结果确实如同预料般。\r\n### 那这个位运算有啥用呢？\r\n首先\r\n哈哈哈，起码知道，在JS中想得到除以某个数舍小数位，只要右移或者左移0位就行了，像```console.log(5/2 >> 0);---->2```这样。\r\n除了这个发现之外，其实位运算确实挺方便的，比如\r\n想要放大或者缩小2的N次幂的倍数，只要左移或者右移N位就行了\r\n\r\n![1位是为2的1次幂](http://upload-images.jianshu.io/upload_images/5176645-956c7d2aeb6d2fb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n移几位这个可能会迷糊，其实联想下十进制就行了，500右移一位变成50，缩小了10倍，右移两位变成5，缩小了100倍也就是10的2次幂，所以无论什么进制都一样，移动N位，就变化进制的N次幂\r\n其次还有一个，如何**快速得到某个数最接近的偏大2的次幂数**，比如15--16,16--16,17--32\r\n答案就在HashMap的源码\r\n\r\n![](http://upload-images.jianshu.io/upload_images/5176645-42845f7656be2a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n重点是```n |= n >>> N```这几行代码，画个图就懂了\r\n![image.png](http://upload-images.jianshu.io/upload_images/5176645-384a01bb437369d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n因为进行了多次|=运算的运算，所以可以确保从最高位到最低位都是1，也就是值为2的N次方-1\r\n其中因为java中int的长度为32为，所以有```n |= n >>> 16;```，这样就能确保数很大的时候都能每一位都做过|=运算\r\n\r\n### 总结\r\n其实位运算的骚操作还有很多，只不过水平有限，计算机组成原理学的也不怎么样，所以这些其实也只是小打小闹。\r\n\r\n**水平有限，难免有错，还请诸君指正。**\r\n','2018-03-01 10:10:25',7,3,1,0,0,NULL,'2018-03-01 10:10:25'),(17,'设计模式（一）——面向对象六大原则','>记在前面：这个《设计模式》系列的文章，想了很久才决定写的，一是还是本人的原则，只有通过自己表达出来的东西，才是真正属于你的东西，所以即使写的不好，有什么理解不到位的，被人指出来也挺好的，证明属于我的东西还是有缺漏嘛。二是设计模式这个东西有点虚，特别这篇原则，总觉得还欠缺很多理解。三是看了好几篇设计模式，下面的讨论基本分两种，要么就是一堆Mark，要么就是一堆FXXk，也是有点担心会被骂吧，不过错了被指正也是很正常。不说废话了，上正文。\r\n>本文属于系列文章《设计模式》，附上[文集链接](http://www.jianshu.com/nb/10772951)\r\n\r\n# 一. 单一职责原则\r\n+ 定义：不要存在多于一个导致类变更的原因。简单说，就是一个类只负责一项职责。 \r\n+ 为什么要这个原则：试想，一个类T，用来实现两个职责t1和t2，在需求变更的情况下需要修改t1，可能导致原本正常工作的t2职责出错。\r\n\r\n但是这个原则，其实看到的话，很多人应该都会觉得没啥好看的吧，因为太简单了，而且在写代码的时候，应该都不希望因为修改了一个功能导致其他的功能发生故障。\r\n但是翻了好几篇博客，还有看到的书的作者也是说到，其实并没有很多类设计能完全遵守到单一职责原则，因为这个原则受太多因素制约了，比如下面这个例子：\r\n\r\n我们要造车，然后要车跑起来\r\n```\r\npublic class Car {\r\n	public void run(String carType){\r\n		System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}	\r\n}\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		Car c = new Car();\r\n		c.run(\"BMW\");\r\n		c.run(\"Benz\");\r\n	}\r\n}\r\n结果：\r\n  启动BMW引擎跑起来了\r\n  启动Benz引擎跑起来了\r\n```\r\n\r\n后面发现还有类似上世纪的小包车这种需要拉才能跑起来的车，我们怎么办呢？\r\n首先按照单一职责原则，我们来另起一个类，来实现这个功能\r\n```\r\npublic class Trolley {\r\n	public void run(String carType){\r\n		System.out.println(\"拉着\"+carType+\"跑起来了\");\r\n	}\r\n}\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		Car c = new Car();\r\n		c.run(\"BMW\");\r\n		c.run(\"Benz\");\r\n		Trolley trolley = new Trolley();\r\n		trolley.run(\"上世纪的小包车\");\r\n	}\r\n}\r\n结果：\r\n启动BMW引擎跑起来了\r\n启动Benz引擎跑起来了\r\n拉着上世纪的小包车跑起来了\r\n```\r\n但是这里就有一个问题了，如果后期还有斗车这种要推的车，还有自行车这种要骑的车，还有几十种其他的车，那我们难道要一个类一个类的写吗？这样会造成类膨胀的。而且修改了类，还得大幅度修改客户端\r\n所以在这里，再引入这个原则的同时，就得违背下这个原则了，如下:\r\n```\r\npublic class Car {\r\n	public void run(String carType){\r\n		System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}\r\n	public void run2(String carType){\r\n		System.out.println(\"拉着\"+carType+\"跑起来了\");\r\n	}\r\n}\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		Car c = new Car();\r\n		c.run(\"BMW\");\r\n		c.run(\"Benz\");\r\n		c.run2(\"上世纪的小包车\");\r\n	}\r\n}\r\n结果：\r\n启动BMW引擎跑起来了\r\n启动Benz引擎跑起来了\r\n拉着上世纪的小包车跑起来了\r\n```\r\n这样做的一个好处就是方便，直接在类里面新添加一个方法，在客户端只需要做小小的改动就可以用。这只是其中一个办法，当然，还有很多种办法，比如在run方法中根据carType判断来选择方式等等，但是这都违背了单一职责原则。所以这个原则怎么用呢？个人理解，很多时候我们在实际的编码过程中并不能完全遵守这个原则，我们只能尽量做到这个原则。不然的话就是死守教规了。\r\n\r\n# 二. 里氏替换原则\r\n\r\n+ 定义：所有引用父类的地方必须能透明地使用其子类的对象。\r\n\r\n+ 为什么要用这个原则：试想一下，在一个类P1中，实现了方法m1，然后现在需要扩展m1方法，新的方法m2由P1的子类来完成，在完成m2的同时，有可能会将m1的方法破坏掉，使得m1不能正常工作。\r\n\r\n上代码,还是用上文的例子：\r\n```\r\npublic class Car {\r\n	public void run(String carType){\r\n		System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}\r\n}\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		Car c = new Car();\r\n		c.run(\"BMW\");\r\n	}\r\n}\r\n结果：\r\n启动BMW引擎跑起来了\r\n```\r\n\r\n现在需要加一个功能，就是对行车的速度进行汇报，怎么做？首先想到的是不是直接修改Car的run方法，但是要注意，这个不是一个好的方法，修改了这个run方法，可能会导致本来在使用这个方法的其他对象产生错误的结果，所以不能这样，我们使用继承，然后重写run方法，如下：\r\n```\r\npublic class AdvancedCar extends Car{\r\n	@Override\r\n	public void run(String carType) {\r\n		super.run(carType);\r\n		System.out.println(\"车的速度是80KM/h\");\r\n	}\r\n}\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		AdvancedCar car = new AdvancedCar();\r\n		car.run(\"BMW\");\r\n	}\r\n}\r\n结果：\r\n启动BMW引擎跑起来了\r\n车的速度是80KM/h\r\n```\r\n然后这里的确实现了功能，而且代码还很整洁，只是一个继承然后加多一句就好了，但是问题就来了，假设再来需求，上班高峰期的时候塞车，不需要汇报速度，下班加班赶回家才需求汇报速度（保平安嘛），那咋办？在这个AdvancedCar中，run方法一经调用，就会汇报速度的喔。用里氏替换原则来看，Car出现的地方，AdvancedCar就不能用了，我们来用里氏替换原则修改下代码：\r\n```\r\npublic class AdvancedCar extends Car{\r\n	public void showSpeed(){\r\n		System.out.println(\"车的速度是80KM/h\");\r\n	}\r\n}\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		AdvancedCar car = new AdvancedCar();\r\n		car.run(\"BMW\");\r\n		car.showSpeed();\r\n	}\r\n}\r\n结果：\r\n启动BMW引擎跑起来了\r\n车的速度是80KM/h\r\n```\r\n这样修改之后，Car出现的地方，AdvancedCar也能直接使用，因为run方法的原有功能并没有被破坏，而且要满足上一段需求的话，只需要直接在Client这里加判断就好。\r\n所以我自己的粗略理解就是：子类可以扩展父类的方法，但不应该复写父类的方法。\r\n# 三. 依赖倒置原则\r\n\r\n+ 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\r\n\r\n+ 为什么要用这个原则：假设一个类P组合了一个类A，然后用A实现了相关的功能，然后现在要将A实现的功能改成B类来实现，这里的修改方法是只能去修改P的代码，而这种直接修改代码是会带来不必要的风险的。\r\n\r\n上例子,还是用车的例子：\r\n```\r\npublic class Car {\r\n    // 给汽车加油\r\n	public void refuel(Gasoline90 gasoline){\r\n		System.out.println(\"加了型号为\"+gasoline.getClass().getSimpleName()+\"的汽油\");\r\n	}\r\n}\r\npublic class Gasoline90 { }\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		Car car = new Car();\r\n		car.refuel(new Gasoline90());\r\n	}\r\n}\r\n结果：\r\n加了型号为Gasoline90的汽油\r\n```\r\n现在问题来了，加油站没有90汽油了，只有93和97，而汽车没油了，难道但是加油refuel(Gasoline90 gasoline)只能加90汽油，咋办,难不成直接修改car的代码，给它多加两个方法，分别可以加93和97汽油？很明显不科学嘛，一点代码复用都没有，更别谈设计模式了，所以在这里，就要改了。\r\n```\r\n// 定义一个接口Gasoline\r\npublic interface Gasoline { }\r\n\r\n//在Car类的refuel方法中传入Gasoline参数\r\npublic class Car {\r\n	public void refuel(Gasoline gasoline){\r\n	System.out.println(\"加了型号为\"+gasoline.getClass().getSimpleName()+\"的汽油\");\r\n	}\r\n}\r\n\r\n// 写90和97两个汽油的类\r\npublic class Gasoline90 implements Gasoline{ }\r\npublic class Gasoline97 implements Gasoline{ }\r\n\r\n// 场景\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n	Car car = new Car();\r\n //car.refuel(new Gasoline90());\r\n	System.out.println(\"----汽车站没有90汽油了-----\");\r\n	car.refuel(new Gasoline97());\r\n	}\r\n}\r\n\r\n结果：\r\n----汽车站没有90汽油了-----\r\n加了型号为Gasoline97的汽油\r\n```\r\n在上面的例子，传参的时候传入了一个Gasoline类型，只要汽车要加的汽油，全都实现这个借口，就可以让汽车自由加油，管它什么93,97,1997都好，而且还不用修改Car的代码，只需要实现Gasoline接口就好。\r\n\r\n# 四. 接口隔离原则\r\n\r\n咋看一下，我以为像现实生活中那样，隔离病原体是把病原体隔离开来，那接口隔离原则难道是隔离接口？编程界的名词确实不能一般对待。\r\n+ 定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上\r\n+ 为什么需要这个原则：假想我们设计了一个接口I，里面有五个方法，分别是m1,m2,m3,m4,m5，而有两个类A和B，分别需要用m1m2m5,m3,m4,m5方法。那么无论是那一个类，在实现接口I的时候，都要将其本身不需要的类进行实现，很明显，这不是一个好设计。\r\n上代码，还是用车的例子：\r\n```\r\n// 接口\r\npublic interface ICar {\r\n	public void run(String carType);\r\n	public void showSpeed();\r\n	public void playMusic(String songName);\r\n}\r\n\r\n// 实现类\r\npublic class Car implements ICar{\r\n    public void run(String carType){\r\n     System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}\r\n	public void showSpeed() {\r\n     System.out.println(\"汽车的速度为80KM/h\");\r\n	}\r\n	public void playMusic(String songName) {\r\n	System.out.println(\"放起了动听的\"+songName);\r\n	}\r\n}\r\n\r\n// 场景\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n	Car car = new Car();\r\n	car.run(\"BMW\");\r\n	car.showSpeed();\r\n	car.playMusic(\"成都\");\r\n	}\r\n}\r\n```\r\n这里问题就来了，并不是所有的车都有放音乐的功能，也并不是所有的车都有展示速度的功能，但是只有上面代码这个车的话，我们在新建其他车对象的时候，却带上了全部的功能，显然，这是不科学的。改进下，将上面的接口拆分成两个接口专业的车```IProfessionalCar```和娱乐功能的车```IEntertainingCar```\r\n```\r\n// 接口\r\npublic interface IProfessionalCar {\r\n	public void run(String carType);\r\n	public void showSpeed();\r\n}\r\npublic interface IEntertainingCar {\r\n	public void run(String carType);\r\n	public void playMusic(String songName);\r\n}\r\n\r\n// 实现类\r\npublic class ProfessionalCar implements IProfessionalCar {\r\n	public void run(String carType){\r\n	System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}\r\n	public void showSpeed() {\r\n	System.out.println(\"汽车的速度为80KM/h\");\r\n	}\r\n}\r\npublic class EntainingCar implements IEntertainingCar {\r\n	public void run(String carType){\r\n	System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}\r\n	public void playMusic(String songName) {\r\n	System.out.println(\"放起了动听的\"+songName);\r\n	}\r\n}\r\n\r\n// 场景\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n	IProfessionalCar professionalCar = new ProfessionalCar();\r\n	professionalCar.run(\"F1方程式\");\r\n	professionalCar.showSpeed();\r\n	EntainingCar entainingCar = new EntainingCar();\r\n	entainingCar.run(\"坏了速度仪表盘的SUV\");\r\n	entainingCar.playMusic(\"成都\");\r\n	}\r\n}\r\n结果：\r\n启动F1方程式引擎跑起来了\r\n汽车的速度为80KM/h\r\n启动坏了速度仪表盘的SUV引擎跑起来了\r\n放起了动听的成都\r\n```\r\n接口隔离原则的要求我们，建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。这通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\r\n\r\n# 五. 迪米特法则\r\n+ 定义：一个对象应该对其他对象保持最少的了解。\r\n+ 为什么需要这个原则：原因就是一个对象对另一个对象了解得越多，那么，它们之间的耦合性也就越强，当修改其中一个对象时，对另一个对象造成的影响也就越大。\r\n\r\n上例子，还是用车：\r\n```\r\n// 车\r\npublic class Car {\r\n	private String carType;\r\n	public Car(String carType){\r\n		this.carType = carType;\r\n	}\r\n	public void run(){\r\n		System.out.println(\"启动\"+carType+\"引擎跑起来了\");\r\n	}\r\n	public void refuel(Gasoline gasoline){\r\n		System.out.println(\"加了型号为\"+gasoline.getName()+\"汽油\");\r\n	}\r\n}\r\n// 汽油\r\npublic class Gasoline {\r\n	private String name;\r\n	public Gasoline(String name) {\r\n		this.name = name;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n    private boolean quality = true;\r\n	public boolean getQuality(){\r\n		return this.quality;\r\n	}\r\n}\r\n// 人\r\npublic class Person {\r\n	private Car car;\r\n	public void setCar(Car car) {\r\n		this.car = car;\r\n	}\r\n	public void drive(){\r\n		car.run();\r\n	}\r\n	public void refuel(Gasoline gasoline){\r\n        if(gasoline.getQuality()){\r\n			System.out.println(\"油的质量过关，可以放心加\");\r\n			car.refuel(gasoline);\r\n		}\r\n}\r\n// 场景类\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		Person jack = new Person();\r\n		jack.setCar(new Car(\"Suv\"));\r\n		jack.drive();\r\n		System.out.println(\"*********开了三百公里，没油了********\");\r\n		jack.refuel(new Gasoline(\"90\"));\r\n	}\r\n}\r\n结果：\r\n启动Suv引擎跑起来了\r\n*********开了三百公里，没油了********\r\n油的质量过关，可以放心加\r\n加了型号为90汽油\r\n```\r\n我们可以看到，一个很符合生活的场景，jack开车，然后开太久了，没油了，于是加油，但是问题就来了，在生活中，加油这个动作应该是jack和加油站的工作人员进行交涉，然后由加油站的工作人员来完成，而在上面这里，则是由jack自己完成。而且对油的质量的检验，我们普通人怎么会，肯定不行啊，万一90,93,97的检验方法各不相同，万一以后的油质量越来越不好，检验步骤要变，难道要修改Person类的方法，不对啊。\r\n我们来改下\r\n```\r\n// 增加类加油站工人\r\npublic class WorkerInPetrolStation {\r\n	public void refuel(Car car, String gasolineName) {\r\n	Gasoline gasoline = new Gasoline(gasolineName);\r\n	if (gasoline.getQuality()) {\r\n	System.out.println(\"油的质量过关，可以放心加\");\r\n	car.refuel(gasoline);\r\n	}\r\n	}\r\n}\r\n// 将Person的refuel方法修改成依赖工人\r\npublic class Person {\r\n	private Car car;\r\n	public void setCar(Car car) {\r\n	this.car = car;\r\n	}\r\n	public void drive(){\r\n	car.run();\r\n	}\r\n	public void refuel(WorkerInPetrolStation worker, String gasolineName){\r\n	worker.refuel(this.car, gasolineName);\r\n	}\r\n}\r\n// Car，Gasoline不变\r\n// 场景类\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n	Person jack = new Person();\r\n	jack.setCar(new Car(\"Suv\"));\r\n	jack.drive();\r\n	System.out.println(\"*********开了三百公里，没油了********\");\r\n	jack.refuel(new WorkerInPetrolStation(),\"90\");\r\n	}\r\n}\r\n结果：\r\n启动Suv引擎跑起来了\r\n*********开了三百公里，没油了********\r\n油的质量过关，可以放心加\r\n加了型号为90汽油\r\n```\r\n现在无论以后油那边怎么变，都和我们Persion无关，交给加油站工人嘛，这是他们的饭碗。\r\n迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。\r\n\r\n# 六. 开闭原则\r\n\r\n+ 定义：对修改关闭，对扩展开放\r\n+ 为什么使用这个原则：这不就是代码重用的一个终极目标吗，不实现这个原则，改代码改到怀疑人生啊！而上面的五个原则，其实就是这个原则的体现。\r\n但是这个原则，正是因为太高级了，所以太虚了，虚的没什么套路可寻，只能靠经验，领悟来慢慢体会。\r\n\r\n# 总结：\r\n以上就是我对这六个原则的简单理解，例子也不知道举得恰不恰当，文字的描述也不知道是不是到位，但是这也就是我的理解了，等深入这行有一定时间，或许会对这篇东西觉得很傻，噗嗤一声，完全不屑。但也是以后的事了。\r\n欢迎前来责骂。。。','2018-03-01 10:10:57',7,3,1,0,0,NULL,'2018-03-01 10:10:57'),(18,'设计模式（二）——单例模式','>本文属于系列文章《设计模式》，附上[文集链接](http://www.jianshu.com/nb/10772951)\r\n\r\n### 单例模式定义\r\n\r\n+ 确保对象在内存中有且只有一个，并自行实例化为系统提供这个实例。\r\n+ 这个模式在我们只需要一个创建一个对象，避免重复创建对象的时候使用，比如说配置文件，工具类，缓存，线程池，日志对象等等\r\n+ 单例模式属于创建类模式\r\n\r\n### 实现方式一 饿汉模式\r\n```\r\n   //1.将构造函数私有化\r\n    private SingleTon(){ }\r\n    //2、内部调用构造函数创建对象，对象声明为私有属性\r\n    // (饿汉模式的命名由此而来，因为SingleTon对象是static的，在加载SingleTon类的时候，instance对象就会被创建，无论有没有使用该对象，都会创建对象，就像饿汉去餐厅吃饭，无论吃不吃，先点了再说 )\r\n    // final关键字确保该实例对象是内存中有且只有一个\r\n    private final static SingleTon instance = new SingleTon();\r\n    //3、提供方法获取singleTon实例\r\n    public static SingleTon getInstance(){\r\n        return instance;\r\n    }\r\n```\r\n\r\n#### 分析\r\n将实例声明为static属性，在类被加载的时候就会创建实例，final属性确保了对象的唯一性。\r\n\r\n### 实现方式二 懒汉模式\r\n```\r\n   //1.将构造函数私有化\r\n    private SingleTon(){ }\r\n    // 2.2、声明一个SingleTon对象，注意，是声明\r\n    private static SingleTon instance = null;\r\n     //3、提供方法获取singleTon实例\r\n    public static SingleTon getInstance(){\r\n        return instance;\r\n    }\r\n```\r\n\r\n#### 分析\r\n这个一般叫做懒汉模式，因为是懒加载嘛，只有对象要被使用的时候才会实例化,但是这里就有一个问题了，假设在多线程的情况下，就会容易会创建多个实例，这不符合单例模式的定义，所以修改下\r\n\r\n### 绝对安全的懒汉模式\r\n```\r\n   //1.将构造函数私有化\r\n    private SingleTon(){ }\r\n    // 2.2、声明一个SingleTon对象，注意，是声明\r\n    private static SingleTon instance = null;\r\n    // 3 在之前的基础上增加了synchronized关键字和一个instance判空\r\n    public static synchronized SingleTon getInstance(){\r\n	    if(instance == null){\r\n		    Thread.sleep(1000);\r\n		    instance = new SingleTon();\r\n	    }\r\n	    return instance;\r\n    }\r\n```\r\n\r\n### 单例模式扩展：指定数量的对象\r\n哈哈，在书上看到的，虽然不知道能不能用上，但是当做活跃下思维吧，觉得挺好玩的。\r\n\r\n```\r\n// 单例类\r\npublic class Singleton {\r\n	private Singleton(String name){\r\n		nameList.add(name);\r\n	}\r\n	// 对象的最大个数\r\n	private static int maxNumOfSingleton = 3;\r\n	//定义对象列表\r\n	private static ArrayList<Singleton> singletonList = new ArrayList<Singleton>();\r\n	// 定义对象的名字列表，方便知道是哪个对象\r\n	private static ArrayList<String > nameList = new ArrayList<>();\r\n	//当前对象的序号\r\n	private static int countNum;\r\n	static{\r\n		// 实例化\r\n		for(int i = 1;i<=maxNumOfSingleton;i++){\r\n			singletonList.add(new Singleton(i +\"号对象\"));\r\n		}\r\n	}\r\n	public static Singleton getInstance(){\r\n		countNum = new Random().nextInt(maxNumOfSingleton);\r\n		return singletonList.get(countNum);\r\n	}\r\n	public void say(){\r\n		System.out.println(\"我是\"+nameList.get(countNum));\r\n	}\r\n}\r\n// 场景\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		for(int i =0;i<5;i++){\r\n			Singleton.getInstance().say();\r\n		}\r\n	}\r\n}\r\n结果：\r\n我是3号对象\r\n我是3号对象\r\n我是1号对象\r\n我是2号对象\r\n我是1号对象\r\n```\r\n\r\n 以上就是单例模式','2018-03-01 10:11:22',7,3,3,0,0,NULL,'2018-03-01 10:11:22'),(19,'设计模式（三）——工厂模式','>本文属于系列文章《设计模式》，附上[文集链接](http://www.jianshu.com/nb/10772951)\r\n\r\n# 工厂模式定义\r\n+ 定义一个创建对象的接口，由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类\r\n+ 作用：没使用工厂的话，我们要创造对象使用new，工厂方法就是帮我们负责创建需要的对象。\r\n+ 工厂模式是创建类模式。\r\n\r\n# 实现\r\n先看一下没用到工厂类的场景，我们需要AProduct和BProduct\r\n```\r\n//产品类接口\r\npublic interface IProduct {\r\n	public void say();\r\n}\r\n// A产品类\r\npublic class AProduct implements IProduct {\r\n	@Override\r\n	public void say() {\r\n		System.out.println(\"我是A产品\");\r\n	}\r\n}\r\n//B产品类\r\npublic class BProduct implements IProduct {\r\n	@Override\r\n	public void say() {\r\n		System.out.println(\"我是B产品\");\r\n	}\r\n}\r\n//场景类\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		IProduct aProduct = new AProduct();\r\n		aProduct.say();\r\n		IProduct bProduct = new BProduct();\r\n		bProduct.say();\r\n	}\r\n}\r\n结果：\r\n我是A产品\r\n我是B产品\r\n```\r\n完美运行，但是这个有什么问题呢？试想一下，假设以后改需求，需要在生产产品的时候传入生产批次，怎么传？构造函数或者setter都可以，但是都有一个问题，就是我们在改了产品类的时候，还得改正在使用它的地方，这个耦合其实可以解的，用的就是工厂方法。\r\n\r\n```\r\n// 抽象工厂类\r\npublic abstract class AbstractFactory {\r\n	public  abstract <T extends IProduct> T  getProduct(Class<T> clazz) ;\r\n}\r\n// 具体工厂类\r\npublic class ConcreteFactory extends AbstractFactory{\r\n	@Override\r\n	public <T extends IProduct> T getProduct(Class<T> clazz) {\r\n		T product = null;\r\n		try {\r\n			product = (T) Class.forName(clazz.getName()).newInstance();\r\n		} catch (Exception e) {\r\n		}\r\n		return product;\r\n	}\r\n}\r\n// 产品类不变\r\n// 场景类\r\npublic class Client {\r\n	public static void main(String[] args) {\r\n		ConcreteFactory factory = new ConcreteFactory();\r\n		AProduct aproduct = factory.getProduct(AProduct.class);\r\n		aproduct.say();\r\n		BProduct bProduct = factory.getProduct(BProduct.class);\r\n		bProduct.say();\r\n	}\r\n}\r\n结果：\r\n我是A产品\r\n我是B产品\r\n```\r\n\r\n+ 分析下上面的代码，定义了一个抽象工厂类，工厂里面有一个方法，接收参数是继承产品类接口的类的类属性，确保工厂生产出来必定是继承自IProduct的对象。为什么要用泛型？因为你会发现，不用泛型的话，接收的参数不知道该怎么定义，直接用IProduct的class属性的话，在使用ConcreteFactory传参的时候是不能传实现IProduct接口的类的class属性的。\r\n+ 然后结果不变，但是可以发现，依赖关系改变了，没改动代码之前，调用者（场景类）依赖于产品类，只要产品类有改动，都有可能对调用者造成影响。而使用工厂模式后，调用者对产品类的依赖变成了对工厂类的依赖，无论产品类如何变化，调用者都不需要关心，只需要工厂类能够正确返回对象即可，实现了解耦。\r\n\r\n以上就是工厂模式。','2018-03-01 10:11:39',7,3,1,0,0,NULL,'2018-03-01 10:11:39'),(20,'python小爬虫','### 目的：用urllib2，爬一堆风景图片\r\n\r\n### 重点代码\r\n\r\n <code>\r\nresponse = urllib2.urlopen(url).read()\r\n     soup = BeautifulSoup(\r\n        response,               # html字符串\r\n        \'html.parser\',          # html解析器\r\n        from_encoding=\'utf-8\'   # 字符编码\r\n    )\r\n</code>\r\n\r\n+ 其中，urlopen就顾名思义了，可以简单理解为打开一个url，然后获得该URL相对应的东西在python里的对象，然后通过read之后，就得到了页面的所有构成元素了\r\n\r\n+ 先看下urlopen返回的是什么\r\n<code>\r\n if __name__==\'__main__\':\r\n     s = urllib2.urlopen(\'http://www.baidu.com/\')\r\n     print(s.read(100))\r\n</code>\r\nread可以传参数，在这里是读取100个字符，结果如下：\r\n\r\n![可见读取到的是一个完整的HTML页面](http://upload-images.jianshu.io/upload_images/5176645-fa15f0f928e57c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n+ 然后上面重点代码里的soup是一个BeautifulSoup对象，是一个第三方的用于html页面内容解析的库，当创建了一个BeautifulSoup对象之后，就可以用这个对象对html的内容进行解析，比如：\r\n<code>\r\n  attr = {\r\n     \'class\':\'pic\',\r\n }\r\n nodes = soup.find_all(\'a\',attr)\r\n</code>\r\n\r\n+ find_all()函数是查找所有符合参数条件的元素，上面的代码就是查找所有类名为pic的a元素，除了find_all之外，还有一个find元素，是查找符合条件的第一个元素，知道这两个函数之后，已经可以爬东西了。\r\n\r\n<code>\r\nimport urllib2\r\nfrom bs4 import BeautifulSoup\r\ndef spider_image(url,pre_filename):\r\n    response = urllib2.urlopen(url).read()\r\n    soup = BeautifulSoup(\r\n        response,               # html字符串\r\n        \'html.parser\',          # html解析器\r\n        from_encoding=\'utf-8\'   # 字符编码\r\n    )\r\n    attr = {\r\n        \'class\':\'pic\',\r\n    }\r\n    nodes = soup.find_all(\'a\',attr)\r\n    url_list = set()\r\n    for node in nodes:\r\n        try:\r\n            url_list.add(node[\'href\'])\r\n        except:\r\n            pass\r\n    for url in url_list:\r\n        img_html = urllib2.urlopen(url).read()\r\n        soup = BeautifulSoup(\r\n            img_html,        # html字符串\r\n            \'html.parser\',          # html解析器\r\n            from_encoding=\'utf-8\'   # 字符编码\r\n        )\r\n        img_url = soup.find(\'img\',id=\"imgView\")\r\n        img_name = img_url[\'alt\']\r\n        try:\r\n            img = urllib2.urlopen(img_url[\'src\']).read()\r\n            print(u\'正在下载图片:\'+img_name)\r\n            fout = open(pre_filename+img_name+\'.jpg\',\'wb\')\r\n            fout.write(img)\r\n            fout.close()\r\n        except Exception as e:\r\n            print(e)\r\n            pass\r\ndef mkdir(path):\r\n    \\# 引入模块\r\n    import os\r\n    \\# 去除首位空格\r\n    path=path.strip()\r\n    \\# 去除尾部 \\ 符号\r\n    path=path.rstrip(\"\\\\\")\r\n    \\# 判断路径是否存在\r\n    \\# 存在     True\r\n    \\# 不存在   False\r\n    isExists=os.path.exists(path)\r\n    \\# 判断结果\r\n    if not isExists:\r\n        \\# 如果不存在则创建目录\r\n        print path+\' 创建成功\'\r\n        \\# 创建目录操作函数\r\n        os.makedirs(path)\r\n        return True\r\n    else:\r\n        \\# 如果目录存在则不创建，并提示目录已存在\r\n        print path+\' 目录已存在\'\r\n        return False\r\nif __name__==\'__main__\':\r\n    url_list = [\r\n        \'http://www.tooopen.com/img/90_894.aspx\'\r\n    ]\r\n    i = 1\r\n    for url in url_list:\r\n        print(u\'现在开始下载第\'+str(i)+u\'个网站的图片\')\r\n        \\# 定义要创建的目录\r\n        mkpath=\'F:\\\\spider\'+str(i)\r\n        \\# 调用函数\r\n        mkdir(mkpath)\r\n        spider_image(url,\'F://spider//spider_image\'+str(i)+\'//\')\r\n        i = i + 1\r\n</code>\r\n\r\n爬图片的话，其实就是读取到图片之后，转成二进制数据之后，写入文件就行了，然后运行就可以了，然后就看到一堆图片在目录里\r\n![](http://upload-images.jianshu.io/upload_images/5176645-26d993908b90c414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n','2018-03-01 10:12:00',7,3,3,0,0,NULL,'2018-03-01 10:12:00');
/*!40000 ALTER TABLE `topic` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `topic_factor`
--

LOCK TABLES `topic_factor` WRITE;
/*!40000 ALTER TABLE `topic_factor` DISABLE KEYS */;
INSERT INTO `topic_factor` VALUES (1,19,9,9,9,9,9,9,9,9,9,1),(2,12,7,12,7,7,12,7,7,17,12,6),(3,12,7,12,7,7,12,7,7,17,12,7),(4,12,7,12,7,7,12,7,7,17,12,8),(5,12,7,12,7,7,17,7,7,12,12,9),(6,17,7,12,7,7,12,7,7,12,12,10),(7,7,12,7,17,12,7,12,12,7,7,11),(8,12,7,17,7,7,12,7,7,12,12,12),(9,12,7,17,7,7,12,7,7,12,12,13),(10,7,12,7,17,12,7,12,12,7,7,14),(11,12,7,17,7,7,12,7,7,12,12,15),(12,12,7,17,7,7,12,7,7,12,12,16),(13,12,7,17,7,7,12,7,7,12,12,17),(14,12,7,17,7,7,12,7,7,12,12,18),(15,12,7,17,7,7,12,7,7,12,12,19),(16,12,7,17,7,7,12,7,7,12,12,20);
/*!40000 ALTER TABLE `topic_factor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES (1,'admin','123123','fcd1cb8e-b71f-46c3-9974-7225997b40c7','/static/imgs/avatar.png','','https://tomoya.cn','这家伙很懒，什么都没留下~','2017-08-26 09:22:16'),(2,'分享版主','123456','4b7bba26-5f98-421e-b850-10bafa1b0a6a','/static/imgs/avatar.png','','','','2018-02-24 14:46:18'),(3,'博客版主','123456','3e563a75-e4c0-44cb-a185-9690c604dd6a','/static/imgs/avatar.png','','','','2018-02-24 14:52:29'),(4,'外包版主','123456','fd4616c4-807d-4dbf-ba7b-89050355b766','/static/imgs/avatar.png','','','','2018-02-24 14:52:59'),(5,'新闻版主','123456','cd3cefb5-63eb-479c-b8af-00a9f5564b74','/static/imgs/avatar.png','','','','2018-03-01 09:12:34'),(6,'麦克','123123','22c245c6-bf50-4e54-9488-0d10bc61e644','/static/imgs/avatar.png','','','','2018-03-01 09:27:11'),(7,'sivan','123456','c72e125c-6c7e-4490-b04c-8602b93bbf38','/static/imgs/avatar.png','','','','2018-03-01 10:10:12');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `user_factor`
--

LOCK TABLES `user_factor` WRITE;
/*!40000 ALTER TABLE `user_factor` DISABLE KEYS */;
INSERT INTO `user_factor` VALUES (1,19,9,9,9,9,9,9,9,9,9,2),(2,9,9,19,9,9,9,9,9,9,9,3),(3,9,9,9,9,9,9,9,9,19,9,4),(4,9,9,9,9,9,19,9,9,9,9,5),(5,7,7,17,17,17,7,7,7,7,7,6),(6,7,7,17,17,7,7,17,7,7,7,7);
/*!40000 ALTER TABLE `user_factor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `user_roles`
--

LOCK TABLES `user_roles` WRITE;
/*!40000 ALTER TABLE `user_roles` DISABLE KEYS */;
INSERT INTO `user_roles` VALUES (5,1,3),(10,5,4),(11,4,4),(12,3,4),(13,2,4),(14,6,5),(15,7,5);
/*!40000 ALTER TABLE `user_roles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping data for table `user_topic_list`
--

LOCK TABLES `user_topic_list` WRITE;
/*!40000 ALTER TABLE `user_topic_list` DISABLE KEYS */;
/*!40000 ALTER TABLE `user_topic_list` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-03-01 11:25:42
